# Spring Boot について

SpringBoot とは、Java のフレームワーク「Spring」を簡単に利用できるようにしたものである。
Spring の持つ複雑さを隠蔽し、短時間でアプリケーションを開発できることが特長です。設定を自動化し、プロジェクトのセットアップや開発を効率化する。

---

## 1.1 主な特徴

1. **スタンドアローン**: Spring Boot アプリケーションはスタンドアローンで、Tomcat や Jetty のようなアプリケーションサーバが不要である。Java アプリケーションとして実行することができる。
2. **Opinionated Defaults（意見形成済みのデフォルト設定）**: 'starters'と呼ばれるモジュールを使って、自動設定や依存関係の管理を行う。これにより、開発者は必要な依存関係を明示的に指定する必要がなくなる。
3. **自動設定**: Spring Boot はクラスパスの内容、定義済みの Bean、各種プロパティ設定に基づいて、リーズナブルなデフォルト設定を行う。これにより、最小限の設定でアプリケーションを起動できる。
4. **組み込みサーバ**: Spring Boot は Tomcat、Jetty、Undertow などの組み込みサーバを提供している。これにより、独立した Java アプリケーションとしてデプロイできる。

---

## 1.2 Spring Boot の利点

- **ブートストラップ（初期設定）が容易**: Spring Boot はフレームワークやサードパーティのライブラリといった依存関係を管理し、最適な設定を提供する。これにより、新しいプロジェクトの開始が簡単になる。
- **短い開発サイクル**: Spring Boot DevTools を使うと、コード変更をすばやく反映し、アプリケーションの再起動やホットスワップを行うことができる。これにより、開発サイクルが大幅に短縮されます。
- **本番環境へのデプロイが容易**: Spring Boot アプリケーションは JAR ファイルとしてパッケージ化することができる。JAR ファイルはどの Java 環境でも実行でき、本番環境へのデプロイが容易になる。

---

## 1.3 クリーンアーキテクチャについて

クリーンアーキテクチャとは、Robert C. Martin（通称「Uncle Bob」）が提唱したソフトウェア設計のパターンである。以下の 4 つの層から成り立っている。

![クリーンアーキテクチャの図](/images/CleanArchitecture.jpg)

1. エンティティ
2. ユースケース
3. インターフェースアダプタ
4. フレームワークとドライバ

このアーキテクチャでは、外側の層から内側の層への依存性のみを許す。これにより、ビジネスロジック（エンティティとユースケース）はフレームワークや UI、データベースといった具体的な詳細から独立する。

今回は SpringBoot での実装を考えるので、以下の 3 つに焦点を当てる。

### コントローラ (フレームワークとドライバ層)

コントローラはクライアントからの入力を受け取る部分で、リクエストのデータを適切な形式に変換し、必要なユースケースを呼び出す。処理が完了したら、結果をクライアントに適切な形式で返す。

### ユースケース (ユースケース層)

ユースケースはビジネスロジックの中核部分で、具体的なビジネスの操作を定義する。ユースケースは直接エンティティを操作し、エンティティ間の関連性やビジネスルールを管理する。

### ドメイン (エンティティ層)

ドメイン（またはエンティティ）はビジネスの領域モデルを表す。エンティティはビジネスにおける主要な概念やビジネスルールを表現する。各エンティティは一連の属性とそれらの属性を操作するメソッドを持つ。

---

クリーンアーキテクチャの目的は、ソフトウェアの設計と組織を明確にし、ソフトウェアの可読性、拡張性、メンテナンス性を向上させることだ。ビジネスロジックを中心に据え、それを具体的な詳細（フレームワーク、データベース、UI）から独立させることで、これらの目標を達成する。

---

## 1.4 DI(Dependency Injection)について

**ここが一番大事!**

依存性注入（DI）とは、オブジェクト指向プログラミングでの設計パターンの一つだ。クラス間の依存関係をコード内で硬く結びつけるのではなく、外部のシステムが依存関係を注入することで、コンポーネント間の結合度を下げ、テストやメンテナンスを容易にする。

DI は主に次の三つのタイプがある。

1. **コンストラクタ注入**：依存性はコンストラクタのパラメータとして渡される。これは最も一般的な形式で、不変性と一貫性を確保できる。
2. セッター注入：依存性は公開されたセッターメソッドを通じて渡される。後から依存性を変更したり、オプションの依存性を提供する場合に適している。
3. インターフェース注入：依存性を受け入れるクラスはインターフェースを実装し、そのインターフェースに依存性を設定するメソッドが含まれる。

Spring Framework では DI は非常に重要な役割を果たし、特にコンストラクタ注入を推奨している。DI を使用することで、コードはよりモジュール化され、再利用性とテスト可能性が高まる。また、コードはより明確で理解しやすくなる。

---

## 1.5 どうやって DI するか

手順は以下の通り

1. インスタンスの管理を Spring に依頼する
2. インスタンスの依存関係をコンストラクタに記載する

---

### 1.5.1 インスタンスの管理を Spring に依頼する

`@Component` アノテーションをクラスにつけるだけ。アノテーションには以下の種類があるのでアーキテクチャに従ってつける。`@Configuration`+`@Bean`は今回は使わない。

| アノテーション             | 説明                                                                                                                                                                                                                                                                           |
| -------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `@Component`               | Spring が管理する一般的なコンポーネントを示すためのアノテーション。特定の役割がなく、他の特化型アノテーション（`@Service`、`@Controller`、`@Repository`など）の基底アノテーションとなる。                                                                                      |
| `@Service`                 | ビジネスロジックを持つサービス層のクラスを示すアノテーション。明示的に示すだけであり`@Component`との違いは特にない。                                                                                                                                                           |
| `@Controller`              | MVC のコントローラー層のクラスを示すアノテーション。HTTP リクエストを受け取り、適切なビジネスロジック（サービス）を呼び出し、レスポンスを返す。                                                                                                                                |
| `@Repository`              | データストアに対する操作を行う DAO（Data Access Object）クラスを示すアノテーション。データベースアクセスロジックをカプセル化する。データベースアクセス時の例外を Spring の DataAccessException に変換する機能がある。                                                          |
| `@Configuration` + `@Bean` | Spring の JavaConfig を示すアノテーション。`@Configuration`が付与されたクラス内の`@Bean`メソッドは、Spring 管理下の Bean を生成する。`@Bean`が付与されたメソッドの戻り値が Spring 管理下の Bean となる。より複雑な依存関係や初期化が必要な Bean を生成する場合などに使用する。 |

細かく言うと`@Component`をつけただけでは Spring に認識されない。
`@ComponentScan`をつけるとそのパッケージの配下の`@Component`アノテーションが自動で検索されて、登録される。`@ComponentScan`アノテーションが単体で使用されることは少なく、`@SpringBootApplication`アノテーションが使われる。`@SpringBootApplication`は以下のアノテーションの集合体である。

1. `@EnableAutoConfiguration`: Spring Boot の自動設定を有効にします。これにより、プロジェクトに含まれる jar 依存関係に基づいて適切なデフォルト設定が自動的に適用されます。たとえば、`spring-boot-starter-web`依存関係がある場合、Spring Boot は自動的に Tomcat と Spring MVC を設定します。

2. `@ComponentScan`: Spring が自動的にプロジェクトの一部（通常は`@SpringBootApplication`が配置されている場所とその下位パッケージ）をスキャンし、`@Component`, `@Service`, `@Repository`, `@Controller`などのアノテーションが付いたクラスを Bean として登録します。

3. `@Configuration`: Java ベースの設定を可能にします。これにより、アプリケーションの設定を XML ではなく Java で書くことができます。また、`@Bean`アノテーションを使って、特定の Bean を明示的に定義することもできます。

---

### 1.5.2 インスタンスの依存関係をコンストラクタに記載する

```Java
@Service
public class MyService {
    private final MyRepository myRepository;

    // コンストラクタを通じた依存性注入
    public MyService(MyRepository myRepository) {
        this.myRepository = myRepository;
    }

    //...
}
```

`@Autowired`アノテーションで省略できる。

```Java
@Service
public class MyService {
    @Autowired
    private MyRepository myRepository;
    //...
}
```

---

### DI イメージ図

![DIの流れの図](/images/di.drawio.png)
